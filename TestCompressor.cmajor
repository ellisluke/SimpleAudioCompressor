
/*
    This file was auto-generated by the cmaj VScode extension!
    https://cmajor.dev
*/

// Here's a very simple graph that plays a sine-wave to get you started..
graph TestCompressor  [[ main ]]
{
    input stream float32 in;
    output stream float32 out;

    input 
    {
        compressor.T [[ name: "Threshold", min: -90.0f, max: 0.0f, init: -20.0f ]]; // in dB
        compressor.R [[ name: "Ratio", min: 1.0f, max: 10.0f, init: 1.0f ]]; // R to 1 ratio
        compressor.attackTime [[ name: "Attack", min: 0.001f, max: 1.0f, init: 0.3f ]];
        compressor.releaseTime [[ name: "Release", min: 0.001f, max: 1.0f, init: 0.3f ]];
    }
    

    node
    {
        noise = RandomValue;
        compressor = Compressor;
    }

    connection
    {
        in -> compressor.in;
        compressor.out -> out;
    }
    
}

processor RandomValue 
{
    output stream float32 out;
    std::random::RNG rand;
    void main()
    {
        loop
        {
            out <- rand.getUnipolar();
            advance();
        }
    }
}

processor Compressor
{
    input stream float32 in;
    output stream float32 out;

    input
    {
        value float32 T; // threshold relative to 0 dBFS
        value float32 R; // ratio (R to 1)
        value float32 attackTime; // attack in seconds
        value float32 releaseTime; // release in seconds
    }

    float32 gainSmoothPrev = 0.0f;
    float32 alphaAttack = 0.0f;
    float32 alphaRelease = 0.0f;
    float32 gainSC = 0.0f;
    float32 gainChange_dB = 0.0f;
    float32 gainSmooth = 0.0f;
    float32 linearAmplitude = 0.0f;

    void main()
    {
        loop{
            // Calculate the attack and release alphas in case a value was updated
            alphaAttack = float32(exp(-log(9.0f)/(processor.frequency * attackTime)));
            alphaRelease = float32(exp(-log(9.0f)/(processor.frequency * releaseTime)));

            // Convert input to useful values
            float32 in_uni = abs(in);
            float32 in_dB = 20 * log10(in_uni / 1);
            if (in_dB < -96.0f)
            {
                in_dB = -96.0f;
            }
            
            // Calculate compressed value where necessary
            if (in_dB > T)
            {
                gainSC = T + (in_dB - T)/R;
            }
            else
            {
                gainSC = in_dB;
            }

            gainChange_dB = gainSC - in_dB;

            // Smooth and apply attack or release
            if (gainChange_dB < gainSmoothPrev) // attack case
            {
                gainSmooth = ((1 - alphaAttack) * gainChange_dB) + (alphaAttack * gainSmoothPrev);
            }
            else // release case
            {
                gainSmooth = ((1 - alphaRelease) * gainChange_dB) + (alphaRelease * gainSmoothPrev);
            }

            // Convert to linear amplitude scalar
            linearAmplitude = pow(10.0f, (gainSmooth/20));
            
            gainSmoothPrev = gainSmooth;

            out <- linearAmplitude * in;
            advance();
        }
    }
}
